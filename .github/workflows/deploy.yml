name: Deploy to Production

on:
  push:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'production'
        type: choice
        options:
          - production
          - staging

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  deploy:
    name: Deploy to ${{ github.event.inputs.environment || 'production' }}
    runs-on: ubuntu-latest
    environment:
      name: ${{ github.event.inputs.environment || 'production' }}
      url: ${{ vars.APP_URL }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.DEPLOY_SSH_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          ssh-keyscan -H ${{ secrets.DEPLOY_HOST }} >> ~/.ssh/known_hosts

      - name: Create deployment package
        run: |
          # Создаем директорию для деплоя
          mkdir -p deployment
          
          # Копируем необходимые файлы
          cp docker-compose.yml deployment/
          cp nginx.conf deployment/
          cp -r scripts deployment/
          
          # Создаем .env файл из секретов
          cat > deployment/.env << EOF
          NODE_ENV=${{ vars.NODE_ENV }}
          DATABASE_URL=${{ secrets.DATABASE_URL }}
          TELEGRAM_TOKEN=${{ secrets.TELEGRAM_TOKEN }}
          OPENROUTER_API_KEY=${{ secrets.OPENROUTER_API_KEY }}
          LEVELTRAVEL_API_KEY=${{ secrets.LEVELTRAVEL_API_KEY }}
          LEVEL_TRAVEL_PARTNER=${{ vars.LEVEL_TRAVEL_PARTNER }}
          APP_URL=${{ vars.APP_URL }}
          REDIS_HOST=${{ vars.REDIS_HOST }}
          REDIS_PORT=${{ vars.REDIS_PORT }}
          REDIS_PASSWORD=${{ secrets.REDIS_PASSWORD }}
          JWT_SECRET=${{ secrets.JWT_SECRET }}
          SESSION_SECRET=${{ secrets.SESSION_SECRET }}
          CSRF_SECRET=${{ secrets.CSRF_SECRET }}
          LOG_LEVEL=${{ vars.LOG_LEVEL }}
          ENABLE_METRICS=${{ vars.ENABLE_METRICS }}
          RATE_LIMIT_MAX=${{ vars.RATE_LIMIT_MAX }}
          RATE_LIMIT_WINDOW_MS=${{ vars.RATE_LIMIT_WINDOW_MS }}
          RUN_MIGRATIONS=${{ vars.RUN_MIGRATIONS }}
          EOF

      - name: Copy files to server
        run: |
          scp -i ~/.ssh/deploy_key -r deployment/* ${{ secrets.DEPLOY_USER }}@${{ secrets.DEPLOY_HOST }}:${{ secrets.DEPLOY_PATH }}/

      - name: Deploy application
        run: |
          ssh -i ~/.ssh/deploy_key ${{ secrets.DEPLOY_USER }}@${{ secrets.DEPLOY_HOST }} << 'EOF'
            cd ${{ secrets.DEPLOY_PATH }}
            
            # Backup текущей версии
            if [ -f docker-compose.yml ]; then
              docker-compose -f docker-compose.backup.yml down || true
              cp docker-compose.yml docker-compose.backup.yml
            fi
            
            # Обновляем образы
            export IMAGE_TAG=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:main
            docker pull $IMAGE_TAG
            
            # Обновляем docker-compose.yml с новым тегом
            sed -i "s|app:.*|app:|g" docker-compose.yml
            sed -i "s|image: app|image: $IMAGE_TAG|g" docker-compose.yml
            
            # Запускаем миграции
            if [ "${{ vars.RUN_MIGRATIONS }}" = "true" ]; then
              docker-compose run --rm app npm run db:migrate
            fi
            
            # Перезапускаем сервисы
            docker-compose up -d --remove-orphans
            
            # Проверяем здоровье приложения
            echo "Waiting for application to be healthy..."
            for i in {1..30}; do
              if curl -f http://localhost:5000/api/health > /dev/null 2>&1; then
                echo "Application is healthy!"
                break
              fi
              if [ $i -eq 30 ]; then
                echo "Health check failed!"
                docker-compose logs app
                exit 1
              fi
              sleep 2
            done
            
            # Очищаем старые образы
            docker image prune -f
          EOF

      - name: Send deployment notification
        if: always()
        uses: 8398a7/action-slack@v3
        with:
          status: ${{ job.status }}
          text: |
            Deployment to ${{ github.event.inputs.environment || 'production' }} ${{ job.status }}
            Commit: ${{ github.sha }}
            Author: ${{ github.actor }}
          webhook_url: ${{ secrets.SLACK_WEBHOOK }}
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK }}

  rollback:
    name: Rollback if needed
    runs-on: ubuntu-latest
    needs: deploy
    if: failure()
    environment:
      name: ${{ github.event.inputs.environment || 'production' }}
    
    steps:
      - name: Set up SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.DEPLOY_SSH_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          ssh-keyscan -H ${{ secrets.DEPLOY_HOST }} >> ~/.ssh/known_hosts

      - name: Rollback to previous version
        run: |
          ssh -i ~/.ssh/deploy_key ${{ secrets.DEPLOY_USER }}@${{ secrets.DEPLOY_HOST }} << 'EOF'
            cd ${{ secrets.DEPLOY_PATH }}
            
            if [ -f docker-compose.backup.yml ]; then
              echo "Rolling back to previous version..."
              docker-compose down
              mv docker-compose.backup.yml docker-compose.yml
              docker-compose up -d
              echo "Rollback completed!"
            else
              echo "No backup found for rollback!"
              exit 1
            fi
          EOF

      - name: Send rollback notification
        uses: 8398a7/action-slack@v3
        with:
          status: custom
          custom_payload: |
            {
              text: "⚠️ Deployment rollback completed for ${{ github.event.inputs.environment || 'production' }}"
            }
          webhook_url: ${{ secrets.SLACK_WEBHOOK }}